Tracker4 {
reference_frame 1174
center {2048 1152}
shutteroffset centred
name MC_Tracker
tile_color 0xbcccdbff
selected true
xpos 273
ypos 677
addUserKnob {20 button +HIDDEN +INVISIBLE}
addUserKnob {22 createPPinUseCurrentFrameBaked -STARTLINE +INVISIBLE T "import aePowerPinFun\naePowerPinFun.createPPinUseReferenceFrameBaked()"}
addUserKnob {22 createPPinUseReferenceFrameBaked -STARTLINE +INVISIBLE T "import aePowerPinFun\naePowerPinFun.createPPinUseReferenceFrameBaked()"}
addUserKnob {20 findD l find4you}
addUserKnob {26 _2 l "" +STARTLINE +INVISIBLE T "<h2>Find position point D"}
addUserKnob {26 _3 l "" -STARTLINE +INVISIBLE T "<font size=\"1\"><i>twss"}
addUserKnob {26 _4 l "" +STARTLINE +INVISIBLE T "point <b>a</b> is always in between two known points (<b>b</b> & <b>c</b>)\n"}
addUserKnob {12 P1 +INVISIBLE}
P1 {{tracks.1.track_x} {tracks.1.track_y}}
addUserKnob {12 P2 +INVISIBLE}
P2 {{tracks.2.track_x} {tracks.2.track_y}}
addUserKnob {12 P3 +INVISIBLE}
P3 {{tracks.3.track_x} {tracks.3.track_y}}
addUserKnob {20 _6 l "" +STARTLINE +INVISIBLE n 1}
addUserKnob {12 A l a +INVISIBLE}
A {{P2} {P2}}
addUserKnob {12 B l b +INVISIBLE}
B {{P1} {P1}}
addUserKnob {12 C l c +INVISIBLE}
C {{P3} {P3}}
addUserKnob {20 endGroup n -1}
addUserKnob {12 D l d t "This will be the 4th point calculated using three other trackers. To aply this on a 4th tracker simply click on the Animation menu button right beside the values --> Copy --> Copy Links\n\nAfter that right click on the 4th tracker \n--> Paste --> Paste Absolute. \n\nAnd thats all!\n\n\n\n\n" +INVISIBLE}
D {{(((A.x-BC.x)*-1)+BC.x)+offsetD.x} {(((A.y-BC.y)*-1)+BC.y)+offsetD.y}}
addUserKnob {20 advanced +INVISIBLE n 1}
addUserKnob {12 BC l bc +INVISIBLE}
BC {{C.x+((B.x-C.x)/2)} {C.y+((B.y-C.y)/2)}}
addUserKnob {12 calctoAB l "calculate to a & b" +INVISIBLE}
calctoAB {{(A.x-B.x)*(1-(2*((A.x-B.x)<0)))} {(A.y-B.y)*(1-(2*((A.y-B.y)<0)))}}
addUserKnob {12 calctoAC l "calculate to a & c" +INVISIBLE}
calctoAC {{(A.x-C.x)*(1-(2*((A.x-C.x)<0)))} {(A.y-C.y)*(1-(2*((A.y-C.y)<0)))}}
addUserKnob {7 distantAB l "distant a & b" +INVISIBLE}
distantAB {{sqrt((calctoAB.x**2)+(calctoAB.y**2))}}
addUserKnob {7 distantAC l "distant a & c" +INVISIBLE}
distantAC {{sqrt((calctoAC.x**2)+(calctoAC.y**2))}}
addUserKnob {12 offsetD l offset +INVISIBLE}
addUserKnob {3 refframe l "reference frame" +INVISIBLE}
refframe 989
addUserKnob {7 aspect l "aspect ratio" t "This is the current aspect ratio of the cornerpin on the timing of the reference frame. You can use this to prevent unwanted scalling of the insert plate.\n\n\n" +INVISIBLE R 0 2}
aspect {{(rint((distantAB(refframe)/distantAC(refframe))*100))/100}}
addUserKnob {20 endGroup_1 l endGroup n -1}
addUserKnob {26 text l "" +STARTLINE T "<h2>Calculate the position of the 4th track"}
addUserKnob {26 text_1 l "" +STARTLINE T "\n"}
addUserKnob {22 python_button_1 l "link 4th track" T "import math\nimport nuke\n\n\n# --- Main Script ---\n\n\n# Get the current node where the script is being run\ntry:\n    node = nuke.thisNode()\nexcept NameError:\n    # Provide a fallback for testing outside of a node context\n    # In a real Nuke environment, this part is not strictly necessary\n    node = nuke.selectedNode()\n    if not node:\n        raise RuntimeError(\"Please select a node with knobs P1, P2, and P3.\")\n\n\ndef get_frame_range_as_list():\n    \"\"\"\n    Opent een dialoogvenster voor een frame-bereik en geeft dit terug\n    als een lijst met twee integers: \[eerste_frame, laatste_frame].\n    \"\"\"\n    # Stel de standaardwaarde in op het frame-bereik van het project\n    default_range = '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame())\n    \n    # Vraag de gebruiker om invoer\n    input_string = nuke.getInput('Enter frame range', default_range)\n\n\n    # 1. Controleer of de gebruiker heeft geannuleerd\n    if input_string is None:\n        print(\"Actie geannuleerd door gebruiker.\")\n        return None  # Geef None terug als er geen invoer is\n\n\n    # 2. Probeer de string te verwerken\n    try:\n        parts = input_string.split('-')\n        # Controleer of de invoer uit exact twee delen bestaat\n        if len(parts) != 2:\n            raise ValueError(\"Ongeldig formaat.\")\n            \n        # Zet de twee delen om naar integers\n        first_frame = int(parts\[0])\n        last_frame = int(parts\[1])\n        \n        return \[first_frame, last_frame]\n\n\n    except ValueError:\n        # Vang fouten op als de conversie naar een getal mislukt \n        # of als het formaat verkeerd is.\n        nuke.message(\"Ongeldig formaat.\\nGebruik 'start-eind', bijvoorbeeld: '100-250'.\")\n        return None\n\n\ndef find_A():\n    \"\"\"\n    Identifies the corner point closest to a 90-degree angle (point_A)\n    and returns an ordered list: \[point_A, other_point_1, other_point_2].\n    \"\"\"\n    # Function to calculate the cosine of the angle at a corner point\n    def get_angle_cosine(p_corner, p_other1, p_other2):\n        \"\"\"Calculates the cosine of the angle formed at p_corner.\"\"\"\n        # Create vectors from the corner to the other two points\n        v1 = (p_other1\[0] - p_corner\[0], p_other1\[1] - p_corner\[1])\n        v2 = (p_other2\[0] - p_corner\[0], p_other2\[1] - p_corner\[1])\n\n\n        # Calculate the dot product of the two vectors\n        dot_product = v1\[0] * v2\[0] + v1\[1] * v2\[1]\n\n\n        # Calculate the magnitude (length) of each vector\n        mag_v1 = math.sqrt(v1\[0]**2 + v1\[1]**2)\n        mag_v2 = math.sqrt(v2\[0]**2 + v2\[1]**2)\n\n\n        # To avoid division by zero, check if magnitudes are non-zero\n        if mag_v1 == 0 or mag_v2 == 0:\n            # Return a value that will never be the minimum\n            return 2.0\n\n\n        # Cosine is the dot product divided by the product of the magnitudes\n        return dot_product / (mag_v1 * mag_v2)\n\n\n    # --- Execution ---\n\n\n    # Store the points and their names in a dictionary for easy access\n    points = \{\n        'P1': node\['P1'].value(),\n        'P2': node\['P2'].value(),\n        'P3': node\['P3'].value()\n    \}\n\n\n    # Calculate the cosine for each point when treated as the corner of the angle\n    cosines = \{\n        'P1': get_angle_cosine(points\['P1'], points\['P2'], points\['P3']),\n        'P2': get_angle_cosine(points\['P2'], points\['P1'], points\['P3']),\n        'P3': get_angle_cosine(points\['P3'], points\['P1'], points\['P2'])\n    \}\n\n\n    # Find the key (point name) with the angle closest to 90 degrees.\n    point_A = min(cosines, key=lambda k: abs(cosines\[k]))\n\n\n    # Create a list of the other points\n    other_points = \[p for p in points.keys() if p != point_A]\n\n\n    # Combine point_A and the other points into the final ordered list\n    ordered_list = \[point_A] + other_points\n\n\n    # Display the result to the user in a pop-up message\n    # nuke.message(f\"<b>Geordende punten:</b> \{ordered_list\}\")\n    \n    # Return the ordered list\n    return ordered_list\n\n\ndef get_track_count(tracker_node):\n    tracks = tracker_node\['tracks'].toScript()\n    track_count = len(tracks.split('\\n')) - 36\n    return track_count\n\n\ndef write_keyframes(bake=True):\n    track_index = 4\n    tracks_knob = node\['tracks']\n\n\n    # Bereken de kolom-indices voor track_x en track_y\n    x_col_index = (track_index - 1) * 31 + 2\n    y_col_index = (track_index - 1) * 31 + 3\n\n\n    # --- STEP 1: SET EXPRESSION ---\n    print(\"Stap 1: Expressies instellen...\")\n    x_expression = \"D.x\"\n    y_expression = \"D.y\"\n    tracks_knob.setExpression(x_expression, x_col_index)\n    tracks_knob.setExpression(y_expression, y_col_index)\n\n\n    # --- STAP 2: BAKE EXPRESSION INTO KEYFRAMES ---\n    if bake:\n        print(\"Stap 2: Expressies baken...\")\n        frame_range = get_frame_range_as_list()\n        nuke.animation(f\"\{node.name()\}.tracks.4.track_x\", \"generate\", (str(frame_range\[0]), str(frame_range\[1]), \"1\"))\n        nuke.animation(f\"\{node.name()\}.tracks.4.track_y\", \"generate\", (str(frame_range\[0]), str(frame_range\[1]), \"1\"))\n\n\n\n\ndef link_and_bake_tracker(bake=True):\n    \"\"\"\n    Stap 1: Koppelt de waarden van de 'D.x' en 'D.y' knobs op deze node\n             aan de x- en y-waarden van de vierde track.\n    Stap 2: Bakt deze koppeling onmiddellijk naar keyframes.\n    \"\"\"\n    try:\n        # --- VOORBEREIDING ---\n        ordered_list = find_A()\n\n\n        node\['A'].setExpression(ordered_list\[0])\n        node\['B'].setExpression(ordered_list\[1])\n        node\['C'].setExpression(ordered_list\[2])\n\n\n        tracker_count = get_track_count(node)\n\n\n        if tracker_count < 3:\n            nuke.alert('You need 3 trackers to calculate the 4th tracker')\n        elif tracker_count == 3:\n            node\['add_track'].execute()\n            write_keyframes(bake)\n        elif tracker_count == 4:\n            write_keyframes(bake)\n        else:\n            nuke.alert('This script can only calculate the 4th point if there are 3 trackers.')\n\n\n    except Exception as e:\n        nuke.message(f\"Een onverwachte fout is opgetreden: \{e\}\")\n\n\n\n\n# --- Voer de functie uit ---\nlink_and_bake_tracker(False)" +STARTLINE}
addUserKnob {22 python_button l "Bake 4th track" -STARTLINE T "import math\nimport nuke\n\n\n# --- Main Script ---\n\n\n# Get the current node where the script is being run\ntry:\n    node = nuke.thisNode()\nexcept NameError:\n    # Provide a fallback for testing outside of a node context\n    # In a real Nuke environment, this part is not strictly necessary\n    node = nuke.selectedNode()\n    if not node:\n        raise RuntimeError(\"Please select a node with knobs P1, P2, and P3.\")\n\n\ndef get_frame_range_as_list():\n    \"\"\"\n    Opent een dialoogvenster voor een frame-bereik en geeft dit terug\n    als een lijst met twee integers: \[eerste_frame, laatste_frame].\n    \"\"\"\n    # Stel de standaardwaarde in op het frame-bereik van het project\n    default_range = '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame())\n    \n    # Vraag de gebruiker om invoer\n    input_string = nuke.getInput('Enter frame range', default_range)\n\n\n    # 1. Controleer of de gebruiker heeft geannuleerd\n    if input_string is None:\n        print(\"Actie geannuleerd door gebruiker.\")\n        return None  # Geef None terug als er geen invoer is\n\n\n    # 2. Probeer de string te verwerken\n    try:\n        parts = input_string.split('-')\n        # Controleer of de invoer uit exact twee delen bestaat\n        if len(parts) != 2:\n            raise ValueError(\"Ongeldig formaat.\")\n            \n        # Zet de twee delen om naar integers\n        first_frame = int(parts\[0])\n        last_frame = int(parts\[1])\n        \n        return \[first_frame, last_frame]\n\n\n    except ValueError:\n        # Vang fouten op als de conversie naar een getal mislukt \n        # of als het formaat verkeerd is.\n        nuke.message(\"Ongeldig formaat.\\nGebruik 'start-eind', bijvoorbeeld: '100-250'.\")\n        return None\n\n\ndef find_A():\n    \"\"\"\n    Identifies the corner point closest to a 90-degree angle (point_A)\n    and returns an ordered list: \[point_A, other_point_1, other_point_2].\n    \"\"\"\n    # Function to calculate the cosine of the angle at a corner point\n    def get_angle_cosine(p_corner, p_other1, p_other2):\n        \"\"\"Calculates the cosine of the angle formed at p_corner.\"\"\"\n        # Create vectors from the corner to the other two points\n        v1 = (p_other1\[0] - p_corner\[0], p_other1\[1] - p_corner\[1])\n        v2 = (p_other2\[0] - p_corner\[0], p_other2\[1] - p_corner\[1])\n\n\n        # Calculate the dot product of the two vectors\n        dot_product = v1\[0] * v2\[0] + v1\[1] * v2\[1]\n\n\n        # Calculate the magnitude (length) of each vector\n        mag_v1 = math.sqrt(v1\[0]**2 + v1\[1]**2)\n        mag_v2 = math.sqrt(v2\[0]**2 + v2\[1]**2)\n\n\n        # To avoid division by zero, check if magnitudes are non-zero\n        if mag_v1 == 0 or mag_v2 == 0:\n            # Return a value that will never be the minimum\n            return 2.0\n\n\n        # Cosine is the dot product divided by the product of the magnitudes\n        return dot_product / (mag_v1 * mag_v2)\n\n\n    # --- Execution ---\n\n\n    # Store the points and their names in a dictionary for easy access\n    points = \{\n        'P1': node\['P1'].value(),\n        'P2': node\['P2'].value(),\n        'P3': node\['P3'].value()\n    \}\n\n\n    # Calculate the cosine for each point when treated as the corner of the angle\n    cosines = \{\n        'P1': get_angle_cosine(points\['P1'], points\['P2'], points\['P3']),\n        'P2': get_angle_cosine(points\['P2'], points\['P1'], points\['P3']),\n        'P3': get_angle_cosine(points\['P3'], points\['P1'], points\['P2'])\n    \}\n\n\n    # Find the key (point name) with the angle closest to 90 degrees.\n    point_A = min(cosines, key=lambda k: abs(cosines\[k]))\n\n\n    # Create a list of the other points\n    other_points = \[p for p in points.keys() if p != point_A]\n\n\n    # Combine point_A and the other points into the final ordered list\n    ordered_list = \[point_A] + other_points\n\n\n    # Display the result to the user in a pop-up message\n    # nuke.message(f\"<b>Geordende punten:</b> \{ordered_list\}\")\n    \n    # Return the ordered list\n    return ordered_list\n\n\ndef get_track_count(tracker_node):\n    tracks = tracker_node\['tracks'].toScript()\n    track_count = len(tracks.split('\\n')) - 36\n    return track_count\n\n\ndef write_keyframes(bake=True):\n    track_index = 4\n    tracks_knob = node\['tracks']\n\n\n    # Bereken de kolom-indices voor track_x en track_y\n    x_col_index = (track_index - 1) * 31 + 2\n    y_col_index = (track_index - 1) * 31 + 3\n\n\n    # --- STEP 1: SET EXPRESSION ---\n    print(\"Stap 1: Expressies instellen...\")\n    x_expression = \"D.x\"\n    y_expression = \"D.y\"\n    tracks_knob.setExpression(x_expression, x_col_index)\n    tracks_knob.setExpression(y_expression, y_col_index)\n\n\n    # --- STAP 2: BAKE EXPRESSION INTO KEYFRAMES ---\n    if bake:\n        print(\"Stap 2: Expressies baken...\")\n        frame_range = get_frame_range_as_list()\n        nuke.animation(f\"\{node.name()\}.tracks.4.track_x\", \"generate\", (str(frame_range\[0]), str(frame_range\[1]), \"1\"))\n        nuke.animation(f\"\{node.name()\}.tracks.4.track_y\", \"generate\", (str(frame_range\[0]), str(frame_range\[1]), \"1\"))\n\n\n\n\ndef link_and_bake_tracker(bake=True):\n    \"\"\"\n    Stap 1: Koppelt de waarden van de 'D.x' en 'D.y' knobs op deze node\n             aan de x- en y-waarden van de vierde track.\n    Stap 2: Bakt deze koppeling onmiddellijk naar keyframes.\n    \"\"\"\n    try:\n        # --- VOORBEREIDING ---\n        ordered_list = find_A()\n\n\n        node\['A'].setExpression(ordered_list\[0])\n        node\['B'].setExpression(ordered_list\[1])\n        node\['C'].setExpression(ordered_list\[2])\n\n\n        tracker_count = get_track_count(node)\n\n\n        if tracker_count < 3:\n            nuke.alert('You need 3 trackers to calculate the 4th tracker')\n        elif tracker_count == 3:\n            node\['add_track'].execute()\n            write_keyframes(bake)\n        elif tracker_count == 4:\n            write_keyframes(bake)\n        else:\n            nuke.alert('This script can only calculate the 4th point if there are 3 trackers.')\n\n\n    except Exception as e:\n        nuke.message(f\"Een onverwachte fout is opgetreden: \{e\}\")\n\n\n\n\n# --- Voer de functie uit ---\nlink_and_bake_tracker(True)"}
addUserKnob {26 _1 l "" +STARTLINE T "\n\n\n\n\n\n"}
addUserKnob {26 _7 l "" +STARTLINE T "<b>made by</b> Yorben otto - 2025"}
addUserKnob {20 button +HIDDEN +INVISIBLE}
addUserKnob {22 createPPinUseCurrentFrameBaked -STARTLINE T "import aePowerPinFun\naePowerPinFun.createPPinUseReferenceFrameBaked()"}
addUserKnob {22 createPPinUseReferenceFrameBaked -STARTLINE T "import aePowerPinFun\naePowerPinFun.createPPinUseReferenceFrameBaked()"}
}
