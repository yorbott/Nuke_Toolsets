set cut_paste_input [stack 0]
version 15.1 v2
push $cut_paste_input
Group {
name Transform_mimic
knobChanged "import nuke\nn = nuke.thisNode()\nk = nuke.thisKnob()\n\nif k.name() in \['scan_limit', 'MBO', 'inputChange']:\n    try:\n        # --- 1. FAST CHECK (Immediate) ---\n        limit = int(n\['scan_limit'].value())\n        mbo = n\['MBO'].value()\n        targets = \[]\n        curr = n.input(1) # Check INPUT 1 Only\n        depth = 0\n        \n        while curr and len(targets) < limit and depth < 100:\n            if curr.Class() == \"Transform\" and not curr\['disable'].value():\n                targets.append(curr.name())\n            curr = curr.input(0)\n            depth += 1\n            \n        sig = str(mbo) + \"|\" + str(limit) + \"|\" + str(targets)\n        \n        # --- 2. COMPARE WITH CACHE ---\n        # If signature is the same, WE STOP HERE. No threading, no lag.\n        if n\['last_chain_state'].value() != sig:\n            n\['last_chain_state'].setValue(sig)\n            \n            # --- 3. SCHEDULE UPDATE ---\n            # Only now do we bother the main thread\n            code = n\['python_logic'].value()\n            nuke.executeInMainThread(lambda: exec(code, \{'nuke': nuke\}))\n            \n    except Exception as e:\n        pass"
tile_color 0xa57aaaff
selected true
xpos -1375
ypos 4686
addUserKnob {20 User}
addUserKnob {26 _3 l "" +STARTLINE T "<h1>TRANSFORM "}
addUserKnob {26 _4 l "" -STARTLINE T "<h1><p style=\"color:#A57AAA;\">mimic</p></h1>"}
addUserKnob {26 _1 l "" +STARTLINE T "\n"}
addUserKnob {7 multiplier l <b>Multiplier</b> t "multiplies all the concatonated transform information."}
multiplier 1
addUserKnob {7 time_offset l "<b>Time Offset</b>" t "adds a time offset to all the concatonated transform information." R -100 100}
addUserKnob {20 group l "" +STARTLINE n 1}
group 0
addUserKnob {3 scan_limit l "Scan Limit" t "How many transforms to look for upstream."}
scan_limit 4
addUserKnob {22 refresh l "Refresh / Rebuild" t "Click this if the upstream chain changed and the tool hasn't updated." -STARTLINE T "n = nuke.thisNode()\nn\['last_chain_state'].setValue('')\ncode = n\['python_logic'].value()\nexec(code)"}
addUserKnob {20 endGroup n -1}
addUserKnob {26 _2 l "" +STARTLINE T "\n"}
addUserKnob {26 ""}
addUserKnob {7 motionblur t "look out! this can be quite performance heavy..."}
motionblur 1
addUserKnob {7 shutter}
shutter 0.5
addUserKnob {4 shutteroffset l "shutter offset" M {centred start end "" ""}}
addUserKnob {6 MBO l "motion blur only" -STARTLINE}
MBO true
addUserKnob {26 _6 l "" +STARTLINE T "\n\n"}
addUserKnob {26 _5 l "" +STARTLINE T "<i>made by Yorben - v1.0"}
addUserKnob {1 python_logic l "Python Logic" +INVISIBLE}
python_logic "import nuke\n\ndef build_mimic_chain():\n    # Use toNode because 'thisNode' can be lost in threads\n    try:\n        node = nuke.thisNode()\n    except:\n        return\n\n    # --- 1. CONFIGURATION ---\n    try:\n        limit = int(node\['scan_limit'].value())\n        mbo_mode = node\['MBO'].value()\n    except ValueError:\n        return\n\n    # --- 2. FAST SCAN ---\n    target_names = \[]\n    current = node.input(1)\n    depth_search = 0\n    while current and len(target_names) < limit and depth_search < 100:\n        if current.Class() == \"Transform\" and not current\['disable'].value():\n            target_names.append(current.name())\n        current = current.input(0)\n        depth_search += 1\n\n    # --- 3. BUILD ---\n    with node:\n        # Clean up old\n        for n in nuke.allNodes():\n            if n.name().startswith(\"Mimic_Gen\"):\n                nuke.delete(n)\n\n        # Start building\n        last_node = nuke.toNode(\"Dot2\")\n        if not last_node: return\n\n        for t_name in reversed(target_names):\n            t = nuke.createNode(\"Transform\", inpanel=False)\n            t.setName(\"Mimic_Gen_\" + t_name)\n            \n            time_off = \"frame + parent.time_offset\"\n            mbo_base = f\"rint(\{time_off\})\"\n            \n            if mbo_mode:\n                tx = f\"(\{t_name\}.translate.x(\{time_off\}) - \{t_name\}.translate.x(\{mbo_base\})) * parent.multiplier\"\n                ty = f\"(\{t_name\}.translate.y(\{time_off\}) - \{t_name\}.translate.y(\{mbo_base\})) * parent.multiplier\"\n                rot = f\"(\{t_name\}.rotate(\{time_off\}) - \{t_name\}.rotate(\{mbo_base\})) * parent.multiplier\"\n                sw = f\"1 + ((\{t_name\}.scale.w(\{time_off\}) - \{t_name\}.scale.w(\{mbo_base\})) * parent.multiplier)\"\n                sh = f\"1 + ((\{t_name\}.scale.h(\{time_off\}) - \{t_name\}.scale.h(\{mbo_base\})) * parent.multiplier)\"\n                skx = f\"(\{t_name\}.skewX(\{time_off\}) - \{t_name\}.skewX(\{mbo_base\})) * parent.multiplier\"\n                sky = f\"(\{t_name\}.skewY(\{time_off\}) - \{t_name\}.skewY(\{mbo_base\})) * parent.multiplier\"\n            else:\n                tx = f\"\{t_name\}.translate.x(\{time_off\}) * parent.multiplier\"\n                ty = f\"\{t_name\}.translate.y(\{time_off\}) * parent.multiplier\"\n                rot = f\"\{t_name\}.rotate(\{time_off\}) * parent.multiplier\"\n                sw = f\"1 + ((\{t_name\}.scale.w(\{time_off\}) - 1) * parent.multiplier)\"\n                sh = f\"1 + ((\{t_name\}.scale.h(\{time_off\}) - 1) * parent.multiplier)\"\n                skx = f\"\{t_name\}.skewX(\{time_off\}) * parent.multiplier\"\n                sky = f\"\{t_name\}.skewY(\{time_off\}) * parent.multiplier\"\n\n            cx = f\"\{t_name\}.center.x(\{time_off\})\"\n            cy = f\"\{t_name\}.center.y(\{time_off\})\"\n\n            t\['translate'].setExpression(tx, 0)\n            t\['translate'].setExpression(ty, 1)\n            t\['rotate'].setExpression(rot)\n            t\['scale'].setExpression(sw, 0)\n            t\['scale'].setExpression(sh, 1)\n            t\['skewX'].setExpression(skx)\n            t\['skewY'].setExpression(sky)\n            t\['center'].setExpression(cx, 0)\n            t\['center'].setExpression(cy, 1)\n            \n            t\['motionblur'].setExpression(\"parent.motionblur\")\n            t\['shutter'].setExpression(\"parent.shutter\")\n            \n            t.setInput(0, last_node)\n            last_node = t\n        \n        out_node = nuke.toNode(\"Output1\")\n        if out_node:\n            out_node.setInput(0, last_node)\n\nbuild_mimic_chain()"
addUserKnob {1 last_chain_state l "Chain State Cache" +INVISIBLE}
last_chain_state "True|4|\[]"
}
Input {
inputs 0
name Input1
xpos 0
ypos -571
}
Dot {
name Dot2
xpos 34
ypos -516
}
Output {
name Output1
xpos 0
ypos 138
}
Input {
inputs 0
name transform
xpos -145
ypos -574
number 1
}
end_group
